
\begin{figure}[h]
\centering
\lstset{style=gpucode,linewidth=6.5in,xleftmargin=0.25in}

\begin{lstlisting}
// Takes the index of two particles and detemines the distance between them
// If the distance is less than the sum of radii squared the are in comllsion.
// If collsiong increment the collsion counter.
uint ProcessParticleContact(uint crnr, uint Findex, uint Tindex, in out vec3 OutVel)
{
	if(Findex == Tindex || Tindex <= bbound)
		return 0;
	
	vec3 U1x,U1y,U2x,U2y,V1x,V1y,V2x,V2y;

	float xT = P[Findex].PosLoc.x;
    float yT = P[Findex].PosLoc.y;
    float zT = P[Findex].PosLoc.z;
	
	float xP = P[Tindex].PosLoc.x;
    float yP = P[Tindex].PosLoc.y;
    float zP = P[Tindex].PosLoc.z;
	
	float Fm 	= P[Findex].MolarMatter;
	float Ft 	= P[Tindex].MolarMatter;
	vec3 InPosF = P[Findex].PosLoc.xyz;
	vec3 InPosT = P[Tindex].PosLoc.xyz;
	vec3 InVelF	= P[Findex].prvvel.xyz;
	vec3 InVelT	= P[Tindex].prvvel.xyz;
	vec3 newVel;
	
    // Get squared distance between centers
    float dsq = ((xP-xT)*(xP-xT)+
                    (yP-yT)*(yP-yT)+
                    (zP-zT)*(zP-zT));
   
	// Get sqaured diameter
	float rsq = ((P[Findex].PosLoc.w+P[Tindex].PosLoc.w)*(P[Findex].PosLoc.w+P[Tindex].PosLoc.w));
	
	// If square of distance is less than square of radii there is a collision.
	if (dsq <= rsq )
    {
		// This particle has collision
		P[Findex].ColFlg = 1;
		
		// Make sur this is not a duplicate collision.
		if(inColl(Findex,Tindex))
		{
			return 0;
		}
		// Calulate the resolution
		CalcMomentum(Findex,Fm,Ft,InPosF,InPosT,InVelF,InVelT,newVel);
		P[Findex].VelRad.xyz = newVel;
		// Count collisions
		atomicAdd(collOut.CollisionCount,1);
		return -1;		
	}
	else
	{
		// Not in collsion anymore
		P[Findex].ColFlg = 0;
		// Clear dup flags
		ClearCflg(Findex,Tindex);
	}


	return 0;
}
\end{lstlisting}


\caption[Benchset test configuration file]{The code for \texttt{ProcessParticleContact(...)} does a distance based contact determination. }
\label{fig:ProcessParticleContact}
\end{figure}
